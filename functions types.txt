row and cols count
check first row cols
cols increase/descrease
first row space
space increment decrement


JavaScript functions can be categorized based on their declaration style and behavior. Here are the main types: Function Declarations (Named Functions).
These are defined using the function keyword followed by a name, parameters, and a function body. They are hoisted, meaning they can be called before their declaration in the code.
JavaScript

    function greet(name) {
      return "Hello, " + name + "!";
    }
Function Expressions.
Functions defined as part of an expression and assigned to a variable. They can be named or anonymous. Function expressions are not hoisted in the same way as declarations; they can only be invoked after their definition.
JavaScript

    const sayHello = function(name) { // Anonymous function expression
      return "Hello, " + name + "!";
    };

    const namedExpression = function myFunc(value) { // Named function expression
      return value * 2;
    };
Arrow Functions (ES6).
A concise syntax for writing function expressions, particularly useful for anonymous functions. They have a lexical this binding, meaning this refers to the this value of the enclosing scope.
JavaScript

    const multiply = (a, b) => a * b; // Concise syntax for single expression

    const greetUser = (name) => { // With a block body
      console.log("Welcome, " + name);
    };
Immediately Invoked Function Expressions (IIFEs).
Functions that are declared and executed immediately after their definition. They are often used to create a private scope for variables, preventing them from polluting the global scope.
JavaScript

    (function() {
      const privateVar = "I am private!";
      console.log(privateVar);
    })();
Callback Functions.
Functions passed as arguments to other functions, to be executed later, typically after an asynchronous operation or an event.
JavaScript

    function fetchData(callback) {
      setTimeout(() => {
        const data = "Some data";
        callback(data);
      }, 1000);
    }

    fetchData((result) => {
      console.log("Received:", result);
    });
Constructor Functions.
Used with the new keyword to create objects. They typically define properties and methods that will be inherited by instances created from them.
JavaScript

    function Person(name, age) {
      this.name = name;
      this.age = age;
      this.greet = function() {
        return "Hi, I'm " + this.name;
      };
    }

    const john = new Person("John", 30);
Async Functions.
Functions marked with the async keyword, which always return a Promise. They allow the use of the await keyword to pause execution until a Promise settles.
JavaScript

    async function fetchDataAsync() {
      const response = await fetch('https://api.example.com/data');
      const data = await response.json();
      return data;
    }
Generator Functions.
Functions marked with an asterisk (*) that can be paused and resumed, producing a sequence of values using the yield keyword. They return a Generator object.
JavaScript

    function* idGenerator() {
      let id = 1;
      while (true) {
        yield id++;
      }
    }

    const gen = idGenerator();
    console.log(gen.next().value); // 1
    console.log(gen.next().value); // 2